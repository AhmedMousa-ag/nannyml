.. _multiclass-performance-calculation:

================================================================
Monitoring Realized Performance for Multiclass Classification
================================================================

Why Monitor Realized Performance
===================================

The realized performance of a machine learning model is the actual performance of the model's outputs compared with 
the :term:`target` values. It is typically a good proxy for the business impact of the model.
A significant drop in performance normally means a lot of the value generated by the model is at risk,
so close monitoring and quick resolution of issues are essential.

This guide shows how to use NannyML to calculate the :term:`Realized Performance` of a multi-class model.
Target values need to be available in both the reference and analysis data.
All monitoring metrics available by NannyML for monitoring will be shown.

.. note::
    The performance monitoring process requires no missing values in the target data on the reference dataset. However,
    the analysis data can contain missing values. The entries with missing values will simply be ignored when
    calculating the performance results. If there are so many missing values that the available data are below the
    :ref:`minimum-chunk-size` then the performance results are omitted from the resulting visualizations because they are
    too noisy to be reliable.

=====================

Just The Code
-------------

.. code-block:: python

    import pandas as pd
    import nannyml as nml
    from IPython.display import display

    reference_df = nml.load_synthetic_binary_classification_dataset()[0]
    analysis_df = nml.load_synthetic_binary_classification_dataset()[1]
    analysis_target_df = nml.load_synthetic_binary_classification_dataset()[2]
    analysis_df = analysis_df.merge(analysis_target_df, on='identifier')

    display(reference_df.head(3))

    calc = nml.PerformanceCalculator(
        y_pred_proba={
            'prepaid_card': 'y_pred_proba_prepaid_card', 
            'highstreet_card': 'y_pred_proba_highstreet_card', 
            'upmarket_card': 'y_pred_proba_upmarket_card'
        }, 
        y_pred='y_pred', 
        y_true='y_true', 
        timestamp_column_name='timestamp', 
        metrics=['roc_auc', 'f1', 'accuracy'],
        chunk_size=6000)

    calc.fit(reference_df)

    results = calc.calculate(analysis_df)

    display(results.data.head(3))

    for metric in calc.metrics:
        figure = results.plot(kind='performance', plot_reference=True, metric=metric)
        figure.show()



Walkthrough
----------------------------------------------


Prepare the data
~~~~~~~~~~~~~~~~

For simplicity the guide is based on a synthetic dataset where the monitored model predicts
which type of credit card product new customers should be assigned to. You can :ref:`learn more about this dataset<dataset-synthetic-multiclass>`.

In order to monitor a model, NannyML needs to learn about it from a reference dataset. Then it can monitor the data that is subject to actual analysis, provided as the analysis dataset.
You can read more about this in our section on :ref:`data periods<data-drift-periods>`

The ``analysis_targets`` dataframe contains the target results of the analysis period. This is kept separate in the synthetic data because it is
not used during :ref:`performance estimation.<performance-estimation>`. But it is required to calculate performance, so the first thing we need to in this case is set up the right data in the right dataframes.  The analysis target values are joined on the analysis frame by the ``identifier`` column.

.. code-block:: python

    import pandas as pd
    import nannyml as nml
    from IPython.display import display

    reference_df = nml.load_synthetic_binary_classification_dataset()[0]
    analysis_df = nml.load_synthetic_binary_classification_dataset()[1]
    analysis_target_df = nml.load_synthetic_binary_classification_dataset()[2]
    analysis_df = analysis_df.merge(analysis_target_df, on='identifier')

    display(reference_df.head(3))

+----+---------------+------------------------+--------------------------+---------------+-----------------------+-----------------+---------------+-------------+--------------+---------------------+-----------------------------+--------------------------------+------------------------------+--------------+---------------+
|    | acq_channel   |   app_behavioral_score |   requested_credit_limit | app_channel   |   credit_bureau_score |   stated_income | is_customer   | partition   |   identifier | timestamp           |   y_pred_proba_prepaid_card |   y_pred_proba_highstreet_card |   y_pred_proba_upmarket_card | y_pred       | y_true        |
+====+===============+========================+==========================+===============+=======================+=================+===============+=============+==============+=====================+=============================+================================+==============================+==============+===============+
|  0 | Partner3      |               1.80823  |                      350 | web           |                   309 |           15000 | True          | reference   |        60000 | 2020-05-02 02:01:30 |                        0.97 |                           0.03 |                         0    | prepaid_card | prepaid_card  |
+----+---------------+------------------------+--------------------------+---------------+-----------------------+-----------------+---------------+-------------+--------------+---------------------+-----------------------------+--------------------------------+------------------------------+--------------+---------------+
|  1 | Partner2      |               4.38257  |                      500 | mobile        |                   418 |           23000 | True          | reference   |        60001 | 2020-05-02 02:03:33 |                        0.87 |                           0.13 |                         0    | prepaid_card | prepaid_card  |
+----+---------------+------------------------+--------------------------+---------------+-----------------------+-----------------+---------------+-------------+--------------+---------------------+-----------------------------+--------------------------------+------------------------------+--------------+---------------+
|  2 | Partner2      |              -0.787575 |                      400 | web           |                   507 |           24000 | False         | reference   |        60002 | 2020-05-02 02:04:49 |                        0.47 |                           0.35 |                         0.18 | prepaid_card | upmarket_card |
+----+---------------+------------------------+--------------------------+---------------+-----------------------+-----------------+---------------+-------------+--------------+---------------------+-----------------------------+--------------------------------+------------------------------+--------------+---------------+


Next a :class:`~nannyml.performance_calculation.calculator.PerformanceCalculator` is created using a list of metrics to calculate (or just one metric), the data columns required for these metrics, and an optional :ref:`chunking<chunking>` specification.

The list of metrics specifies which performance metrics of the monitored model will be calculated. 
The following metrics are currently supported:

- ``roc_auc`` - one vs. the rest, macro averaged
- ``f1`` - macro averaged
- ``precision`` - macro averaged
- ``recall`` - macro averaged
- ``specificity`` - macro averaged
- ``accuracy``

For more information on metrics, check the :mod:`~nannyml.performance_calculation.metrics` module.

.. code-block:: python

    calc = nml.PerformanceCalculator(
        y_pred_proba={
            'prepaid_card': 'y_pred_proba_prepaid_card', 
            'highstreet_card': 'y_pred_proba_highstreet_card', 
            'upmarket_card': 'y_pred_proba_upmarket_card'
        }, 
        y_pred='y_pred', 
        y_true='y_true', 
        timestamp_column_name='timestamp', 
        metrics=['roc_auc', 'f1', 'accuracy'],
        chunk_size=6000)


The new :class:`~nannyml.performance_calculation.calculator.PerformanceCalculator` is fitted using the
:meth:`~nannyml.performance_calculation.calculator.PerformanceCalculator.fit` method on the ``reference`` data.

The fitted :class:`~nannyml.performance_calculation.calculator.PerformanceCalculator` can then be used to calculate
realized performance metrics on all data which has target values available.

.. code-block:: python

    calc.fit(reference_df)

    results = calc.calculate(analysis_df)

NannyML can output a dataframe that contains all the results.

Apart from chunking and chunk and partition-related data, the results data have the a set of columns for each
calculated metric. When taking ``roc_auc`` as an example:

 - ``roc_auc`` - The value of the metric for a specific chunk.
 - ``roc_auc_thresholds`` - A tuple containing the lower and upper thresholds. Crossing them will raise an alert on significant
   metric change. The thresholds are calculated based on the realized performance metric of the monitored model on chunks in
   the ``reference`` period. The thresholds are 3 standard deviations away from the mean performance calculated on
   ``reference`` chunks.
 - ``roc_auc_alert`` - Flag indicating potentially significant performance change. ``True`` if realized performance crosses
   upper or lower threshold.

.. code-block:: python

    display(results.data.head(3))

+----+---------------+---------------+-------------+---------------------+---------------------+-------------+------------------------+-----------+-----------------------------------------+-----------------+----------+-----------------------------------------+------------+
|    | key           |   start_index |   end_index | start_date          | end_date            | partition   |   targets_missing_rate |   roc_auc | roc_auc_thresholds                      | roc_auc_alert   |       f1 | f1_thresholds                           | f1_alert   |
+====+===============+===============+=============+=====================+=====================+=============+========================+===========+=========================================+=================+==========+=========================================+============+
|  0 | [0:5999]      |             0 |        5999 | 2020-05-02 02:01:30 | 2020-05-14 12:25:35 | reference   |                      0 |  0.90476  | (0.900902260737325, 0.9135156728918074) | False           | 0.750532 | (0.741253919065521, 0.7649438592270994) | False      |
+----+---------------+---------------+-------------+---------------------+---------------------+-------------+------------------------+-----------+-----------------------------------------+-----------------+----------+-----------------------------------------+------------+
|  1 | [6000:11999]  |          6000 |       11999 | 2020-05-14 12:29:25 | 2020-05-26 18:27:42 | reference   |                      0 |  0.905917 | (0.900902260737325, 0.9135156728918074) | False           | 0.751148 | (0.741253919065521, 0.7649438592270994) | False      |
+----+---------------+---------------+-------------+---------------------+---------------------+-------------+------------------------+-----------+-----------------------------------------+-----------------+----------+-----------------------------------------+------------+
|  2 | [12000:17999] |         12000 |       17999 | 2020-05-26 18:31:06 | 2020-06-07 19:55:45 | reference   |                      0 |  0.909329 | (0.900902260737325, 0.9135156728918074) | False           | 0.75714  | (0.741253919065521, 0.7649438592270994) | False      |
+----+---------------+---------------+-------------+---------------------+---------------------+-------------+------------------------+-----------+-----------------------------------------+-----------------+----------+-----------------------------------------+------------+


The results can be plotted for visual inspection:

.. code-block:: python

    for metric in calc.metrics:
        figure = results.plot(kind='performance', plot_reference=True, metric=metric)
        figure.show()


.. image:: /_static/tutorial-perf-guide-mc-F1.svg

.. image:: /_static/tutorial-perf-guide-mc-ROC_AUC.svg


Insights
=======================

After reviewing the performance calculation results, we should be able to clearly see how the model is performing against
the targets, according to whatever metrics we wish to track.



What Next
=======================

If we decide further investigation is needed, the :ref:`Data Drift<data-drift>` functionality can help us to see
what feature changes may be contributing to any performance changes.

It is also wise to check whether the model's performance is satisfactory
according to business requirements. This is an ad-hoc investigation that is not covered by NannyML.
